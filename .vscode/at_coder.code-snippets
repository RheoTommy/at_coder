{
  "binary_search": {
    "prefix": "binary_search",
    "body": [
      "/// 関数Fを適用すると[false..false,true..true]の形にできるような配列において、初めてtrueになるIndexを返す",
      "/// O(log n)",
      "pub trait BinarySearch<T> {",
      "    /// 存在しなかった場合は配列の長さを返す",
      "    fn lower_bound(&self, f: impl Fn(&T) -> bool) -> usize;",
      "    /// 存在しなかった場合はNoneを返す",
      "    fn lower_bound_safe(&self, f: impl Fn(&T) -> bool) -> Option<usize>;",
      "}",
      "impl<T> BinarySearch<T> for [T] {",
      "    /// 任意のランダムアクセス可能なスライスに対して実行可能な実装",
      "    fn lower_bound(&self, f: impl Fn(&T) -> bool) -> usize {",
      "        let mut left: isize = -1;",
      "        let mut right = self.len() as isize;",
      "        while right - left > 1 {",
      "            let mid = (left + right) / 2;",
      "            if f(&self[mid as usize]) {",
      "                right = mid;",
      "            } else {",
      "                left = mid;",
      "            }",
      "        }",
      "        right as usize",
      "    }",
      "    fn lower_bound_safe(&self, f: impl Fn(&T) -> bool) -> Option<usize> {",
      "        let i = self.lower_bound(f);",
      "        if i == self.len() {",
      "            None",
      "        } else {",
      "            Some(i)",
      "        }",
      "    }",
      "}",
      "pub fn lower_bound(l: i128, r: i128, f: impl Fn(i128) -> bool) -> i128 {",
      "    let mut left = l;",
      "    let mut right = r;",
      "    while right - left > 1 {",
      "        let mid = (left + right) / 2;",
      "        if f(mid) {",
      "            right = mid;",
      "        } else {",
      "            left = mid;",
      "        }",
      "    }",
      "    right",
      "}"
    ]
  },
  "bit": {
    "prefix": "bit",
    "body": [
      "pub trait Monoid {",
      "    type Item: std::fmt::Debug + Clone;",
      "    fn id() -> Self::Item;",
      "    fn op(a: &Self::Item, b: &Self::Item) -> Self::Item;",
      "    fn sub(a: &Self::Item, b: &Self::Item) -> Self::Item;",
      "}",
      "pub struct BIT<M: Monoid> {",
      "    data: Vec<M::Item>,",
      "}",
      "impl<M: Monoid> BIT<M> {",
      "    pub fn new() -> Self {",
      "        Self {",
      "            data: vec![M::id(); 1],",
      "        }",
      "    }",
      "    pub fn push(&mut self, x: &M::Item) {",
      "        let n = self.data.len();",
      "        let mut tmp = x.clone();",
      "        let mut d = 1;",
      "        let k = n & n.wrapping_neg();",
      "        while d != k {",
      "            tmp = M::op(&self.data[n - d], &tmp);",
      "            d *= 2;",
      "        }",
      "        self.data.push(tmp.clone());",
      "    }",
      "    fn prefix_sum(&self, mut i: usize) -> M::Item {",
      "        let mut res = M::id();",
      "        while i != 0 {",
      "            res = M::op(&res, &self.data[i]);",
      "            i -= i & i.wrapping_neg();",
      "        }",
      "        res",
      "    }",
      "    pub fn add(&mut self, mut i: usize, x: &M::Item) {",
      "        i += 1;",
      "        while i < self.data.len() {",
      "            let tmp = M::op(&self.data[i], x);",
      "            self.data[i] = tmp;",
      "            i += i & i.wrapping_neg();",
      "        }",
      "    }",
      "    pub fn sum(&self, left: usize, right: usize) -> M::Item {",
      "        M::sub(&self.prefix_sum(right), &self.prefix_sum(left))",
      "    }",
      "}",
      "pub struct Add;",
      "pub struct Xor;",
      "impl Monoid for Add {",
      "    type Item = i128;",
      "    fn id() -> Self::Item {",
      "        0",
      "    }",
      "    fn op(a: &Self::Item, b: &Self::Item) -> Self::Item {",
      "        a + b",
      "    }",
      "    fn sub(a: &Self::Item, b: &Self::Item) -> Self::Item {",
      "        a - b",
      "    }",
      "}",
      "impl Monoid for Xor {",
      "    type Item = i128;",
      "    fn id() -> Self::Item {",
      "        0",
      "    }",
      "    fn op(a: &Self::Item, b: &Self::Item) -> Self::Item {",
      "        a ^ b",
      "    }",
      "    fn sub(a: &Self::Item, b: &Self::Item) -> Self::Item {",
      "        a ^ b",
      "    }",
      "}",
      "pub type AddBIT = BIT<Add>;",
      "pub type XorBIT = BIT<Xor>;"
    ]
  },
  "coord_comp": {
    "prefix": "coord_comp",
    "body": [
      "pub fn compress<T: std::hash::Hash + Clone + std::cmp::Ord + std::cmp::Eq>(",
      "    v: &[T],",
      ") -> (Vec<T>, std::collections::HashMap<T, usize>) {",
      "    let mut v = v.iter().collect::<Vec<_>>();",
      "    v.sort();",
      "    v.dedup();",
      "    let mut res = std::collections::HashMap::new();",
      "    let mut zip = Vec::with_capacity(v.len());",
      "    for (i, vi) in v.into_iter().enumerate() {",
      "        zip.push(vi.clone());",
      "        res.insert(vi.clone(), i);",
      "    }",
      "    (zip, res)",
      "}"
    ]
  },
  "enumerate_combination": {
    "prefix": "enumerate_combination",
    "body": [
      "/// 組み合わせ全列挙",
      "pub fn comb(n: usize, k: usize) -> Vec<Vec<usize>> {",
      "    let mut it = Vec::new();",
      "    let mut c = (1 << k) - 1;",
      "    while c < 1 << n {",
      "        let mut v = Vec::new();",
      "        for i in 0..n {",
      "            if (c & 1 << i) != 0 {",
      "                v.push(i);",
      "            }",
      "        }",
      "        it.push(v.into());",
      "        let x = c & -c;",
      "        let y = c + x;",
      "        c = ((c & !y) / x >> 1) | y;",
      "    }",
      "    it",
      "}"
    ]
  },
  "enumerate_permutation": {
    "prefix": "enumerate_permutation",
    "body": [
      "/// 順列を生成する構造体",
      "pub struct Permutation<T: Clone> {",
      "    v: Vec<T>,",
      "    l: Vec<usize>,",
      "    not_start: bool,",
      "}",
      "impl<T: Clone> Permutation<T> {",
      "    /// 順列生成をする構造体の初期化",
      "    pub fn new(v: &Vec<T>) -> Permutation<T> {",
      "        Permutation {",
      "            l: vec![0; v.len()],",
      "            v: v.clone(),",
      "            not_start: true,",
      "        }",
      "    }",
      "}",
      "impl<T: Clone> Iterator for Permutation<T> {",
      "    type Item = Vec<T>;",
      "    fn next(&mut self) -> Option<Vec<T>> {",
      "        if self.not_start {",
      "            self.not_start = false;",
      "            return Some(self.v.clone());",
      "        }",
      "        for n in 0..self.v.len() {",
      "            if self.l[n] < n {",
      "                if (n + 1) % 2 == 1 {",
      "                    self.v.swap(0, n);",
      "                    self.l[n] += 1;",
      "                } else {",
      "                    self.v.swap(self.l[n], n);",
      "                    self.l[n] += 1;",
      "                }",
      "                return Some(self.v.clone());",
      "            } else {",
      "                self.l[n] = 0",
      "            }",
      "        }",
      "        return None;",
      "    }",
      "}",
      "pub trait PermutationWithIterator<T: Clone> {",
      "    fn permutations(&mut self) -> Permutation<T>;",
      "}",
      "impl<I> PermutationWithIterator<I::Item> for I",
      "where",
      "    I: Iterator,",
      "    I::Item: Clone,",
      "{",
      "    /// 順列構造体のイテレーターに対する実装",
      "    fn permutations(&mut self) -> Permutation<<I as Iterator>::Item> {",
      "        Permutation::new(&self.collect::<Vec<_>>())",
      "    }",
      "}"
    ]
  },
  "eratosthenes": {
    "prefix": "eratosthenes",
    "body": [
      "/// 構築O(N log log N)で素因数分解系の操作が高速に行える",
      "pub struct Eratosthenes {",
      "    /// n以下の整数iを割り切る最小の素数",
      "    min_prime: Vec<usize>,",
      "}",
      "impl Eratosthenes {",
      "    /// 構築O(N log log N)",
      "    pub fn new(n: usize) -> Self {",
      "        let mut min_prime = (0..=n).collect::<Vec<_>>();",
      "        let mut i = 2usize;",
      "        while i * i <= n {",
      "            if min_prime[i] == i {",
      "                let mut j = 1;",
      "                while i * j <= n {",
      "                    if min_prime[i * j] == i * j {",
      "                        min_prime[i * j] = i;",
      "                    }",
      "                    j += 1;",
      "                }",
      "            }",
      "            i += 1;",
      "        }",
      "        Self { min_prime }",
      "    }",
      "    /// 素数判定O(1)",
      "    pub fn is_prime(&self, i: usize) -> bool {",
      "        if i <= 1 {",
      "            return false;",
      "        }",
      "        self.min_prime[i] == i",
      "    }",
      "    /// 素因数分解O(log N)",
      "    pub fn factorization(&self, i: usize) -> std::collections::HashMap<usize, usize> {",
      "        assert_ne!(i, 0);",
      "        let mut map = std::collections::HashMap::new();",
      "        let mut now = i;",
      "        while now != 1 {",
      "            let p = self.min_prime[now];",
      "            *map.entry(p).or_insert(0) += 1;",
      "            now /= p;",
      "        }",
      "        map",
      "    }",
      "    /// 最大公約数O((log N)^2)",
      "    pub fn gcd(&self, i: usize, j: usize) -> std::collections::HashMap<usize, usize> {",
      "        assert_ne!(i, 0);",
      "        assert_ne!(j, 0);",
      "        let mut map = std::collections::HashMap::new();",
      "        let im = self.factorization(i);",
      "        let jm = self.factorization(j);",
      "        for (k, v) in im {",
      "            if jm.contains_key(&k) {",
      "                map.insert(k, v.min(jm[&k]));",
      "            }",
      "        }",
      "        map",
      "    }",
      "    /// 最小公倍数O((log N)^2)",
      "    pub fn lcm(&self, i: usize, j: usize) -> std::collections::HashMap<usize, usize> {",
      "        assert_ne!(i, 0);",
      "        assert_ne!(j, 0);",
      "        let mut map = std::collections::HashMap::new();",
      "        let im = self.factorization(i);",
      "        let jm = self.factorization(j);",
      "        for (&k, &v) in &im {",
      "            if jm.contains_key(&k) {",
      "                map.insert(k, v.max(jm[&k]));",
      "            } else {",
      "                map.insert(k, v);",
      "            }",
      "        }",
      "        for (k, v) in jm {",
      "            if !im.contains_key(&k) {",
      "                map.insert(k, v);",
      "            }",
      "        }",
      "        map",
      "    }",
      "}"
    ]
  },
  "lazy_seg_tree": {
    "prefix": "lazy_seg_tree",
    "body": [
      "/// 遅延セグ木にのせるMonoid",
      "pub trait Monoid {",
      "    type Item: std::fmt::Debug + Clone;",
      "    /// 単位元",
      "    fn id() -> Self::Item;",
      "    /// 二項演算",
      "    fn op(a: &Self::Item, b: &Self::Item) -> Self::Item;",
      "}",
      "pub struct LazySegTree<M: Monoid, L: Monoid> {",
      "    data: Vec<M::Item>,",
      "    lazy: Vec<Option<L::Item>>,",
      "    n: usize,",
      "}",
      "impl<M: Monoid, L: Monoid> LazySegTree<M, L> {",
      "    /// すべて単位元で埋めた長さnの遅延セグ木の生成",
      "    pub fn new(n: usize) -> Self {",
      "        let mut i = 1;",
      "        while i < n {",
      "            i *= 2;",
      "        }",
      "        let data = (0..2 * i - 1).map(|_| M::id()).collect::<Vec<_>>();",
      "        Self {",
      "            data,",
      "            lazy: vec![None; 2 * i - 1],",
      "            n: i,",
      "        }",
      "    }",
      "    /// O(n)でスライスからセグ木を生成",
      "    pub fn from_slice(slice: &[M::Item]) -> Self {",
      "        let mut i = 1;",
      "        while i < slice.len() {",
      "            i *= 2;",
      "        }",
      "        let mut data = vec![M::id(); 2 * i - 1];",
      "        for j in 0..slice.len() {",
      "            data[j + i - 1] = slice[j].clone();",
      "        }",
      "        if slice.len() != 1 {",
      "            for j in (0..=(i - 2)).rev() {",
      "                data[j] = M::op(&data[j * 2 + 1], &data[j * 2 + 2]);",
      "            }",
      "        }",
      "        Self {",
      "            data,",
      "            lazy: vec![None; 2 * i - 1],",
      "            n: i,",
      "        }",
      "    }",
      "    /// そのノードの持つ区間の一番左のIndex",
      "    fn start_of_section(&self, mut k: usize) -> usize {",
      "        while k < self.n - 1 {",
      "            k = k * 2 + 1;",
      "        }",
      "        k",
      "    }",
      "    /// そのノードの持つ区間の長さ",
      "    fn len_of_section(&self, mut k: usize) -> usize {",
      "        let mut j = k;",
      "        while k < self.n - 1 {",
      "            k = k * 2 + 1;",
      "            j = j * 2 + 2;",
      "        }",
      "        j - k + 1",
      "    }",
      "    /// 遅延を評価し子ノードに伝播",
      "    fn eval(&mut self, k: usize, apply: &impl Fn(&M::Item, &L::Item, usize, usize) -> M::Item) {",
      "        if let Some(lv) = self.lazy[k].clone() {",
      "            if k < self.n - 1 {",
      "                self.lazy[k * 2 + 1] = Some(L::op(",
      "                    &lv,",
      "                    self.lazy[k * 2 + 1].as_ref().unwrap_or(&L::id()),",
      "                ));",
      "                self.lazy[k * 2 + 2] = Some(L::op(",
      "                    &lv,",
      "                    self.lazy[k * 2 + 2].as_ref().unwrap_or(&L::id()),",
      "                ));",
      "            }",
      "            self.data[k] = apply(",
      "                &self.data[k],",
      "                &lv,",
      "                self.start_of_section(k) + 1 - self.n,",
      "                self.len_of_section(k),",
      "            );",
      "            self.lazy[k] = None;",
      "        }",
      "    }",
      "    fn fold_sub(",
      "        &mut self,",
      "        start: usize,",
      "        end: usize,",
      "        k: usize,",
      "        l: usize,",
      "        r: usize,",
      "        apply: &impl Fn(&M::Item, &L::Item, usize, usize) -> M::Item,",
      "    ) -> M::Item {",
      "        self.eval(k, apply);",
      "        if end <= l || r <= start {",
      "            M::id()",
      "        } else if start <= l && r <= end {",
      "            self.data[k].clone()",
      "        } else {",
      "            let vl = &self.fold_sub(start, end, k * 2 + 1, l, (l + r) / 2, apply);",
      "            let vr = &self.fold_sub(start, end, k * 2 + 2, (l + r) / 2, r, apply);",
      "            M::op(vl, vr)",
      "        }",
      "    }",
      "    pub fn fold(",
      "        &mut self,",
      "        start: usize,",
      "        end: usize,",
      "        apply: &impl Fn(&M::Item, &L::Item, usize, usize) -> M::Item,",
      "    ) -> M::Item {",
      "        self.fold_sub(start, end, 0, 0, self.n, apply)",
      "    }",
      "    pub fn set_section(",
      "        &mut self,",
      "        start: usize,",
      "        end: usize,",
      "        lv: L::Item,",
      "        apply: &impl Fn(&M::Item, &L::Item, usize, usize) -> M::Item,",
      "    ) {",
      "        self.set_section_sub(start, end, 0, 0, self.n, lv, apply)",
      "    }",
      "    fn set_section_sub(",
      "        &mut self,",
      "        start: usize,",
      "        end: usize,",
      "        k: usize,",
      "        l: usize,",
      "        r: usize,",
      "        lv: L::Item,",
      "        apply: &impl Fn(&M::Item, &L::Item, usize, usize) -> M::Item,",
      "    ) {",
      "        self.eval(k, apply);",
      "        if start <= l && r <= end {",
      "            self.lazy[k] = Some(lv.clone());",
      "            self.eval(k, apply);",
      "        } else if start < r && l < end {",
      "            self.set_section_sub(start, end, k * 2 + 1, l, (l + r) / 2, lv.clone(), apply);",
      "            self.set_section_sub(start, end, k * 2 + 2, (l + r) / 2, r, lv.clone(), apply);",
      "            self.data[k] = M::op(&self.data[k * 2 + 1], &self.data[k * 2 + 2]);",
      "        }",
      "    }",
      "}"
    ]
  },
  "lcs": {
    "prefix": "lcs",
    "body": [
      "pub fn lcs<T: Eq + Clone>(s: &[T], t: &[T]) -> (usize, Vec<T>) {",
      "    let mut dp = vec![vec![0; t.len() + 2]; s.len() + 2];",
      "    for i in 0..=s.len() {",
      "        for j in 0..=t.len() {",
      "            if i < s.len() && j < t.len() && s[i] == t[j] {",
      "                dp[i + 1][j + 1] = (dp[i + 1][j + 1]).max(dp[i][j] + 1);",
      "            }",
      "            dp[i + 1][j + 1] = (dp[i + 1][j + 1]).max(dp[i][j]);",
      "            dp[i + 1][j] = (dp[i + 1][j]).max(dp[i][j]);",
      "            dp[i][j + 1] = (dp[i][j + 1]).max(dp[i][j]);",
      "        }",
      "    }",
      "    let mut res = Vec::with_capacity(dp[s.len()][t.len()]);",
      "    let mut i = s.len();",
      "    let mut j = t.len();",
      "    while dp[i][j] != 0 {",
      "        if i > 0 && dp[i - 1][j] == dp[i][j] {",
      "            i -= 1;",
      "            continue;",
      "        } else if j > 0 && dp[i][j - 1] == dp[i][j] {",
      "            j -= 1;",
      "            continue;",
      "        } else {",
      "            res.push(s[i - 1].clone());",
      "            i -= 1;",
      "            j -= 1;",
      "        }",
      "    }",
      "    res.reverse();",
      "    (dp[s.len()][t.len()], res)",
      "}"
    ]
  },
  "lis": {
    "prefix": "lis",
    "body": [
      "/// 関数Fを適用すると[false..false,true..true]の形にできるような配列において、初めてtrueになるIndexを返す",
      "/// O(log n)",
      "pub trait BinarySearch<T> {",
      "    /// 存在しなかった場合は配列の長さを返す",
      "    fn lower_bound(&self, f: impl Fn(&T) -> bool) -> usize;",
      "    /// 存在しなかった場合はNoneを返す",
      "    fn lower_bound_safe(&self, f: impl Fn(&T) -> bool) -> Option<usize>;",
      "}",
      "impl<T> BinarySearch<T> for [T] {",
      "    /// 任意のランダムアクセス可能なスライスに対して実行可能な実装",
      "    fn lower_bound(&self, f: impl Fn(&T) -> bool) -> usize {",
      "        let mut left: isize = -1;",
      "        let mut right = self.len() as isize;",
      "        while right - left > 1 {",
      "            let mid = (left + right) / 2;",
      "            if f(&self[mid as usize]) {",
      "                right = mid;",
      "            } else {",
      "                left = mid;",
      "            }",
      "        }",
      "        right as usize",
      "    }",
      "    fn lower_bound_safe(&self, f: impl Fn(&T) -> bool) -> Option<usize> {",
      "        let i = self.lower_bound(f);",
      "        if i == self.len() {",
      "            None",
      "        } else {",
      "            Some(i)",
      "        }",
      "    }",
      "}",
      "pub fn lis<T: Ord + Clone + MaxIdent>(v: &[T]) -> (usize, Vec<T>) {",
      "    let mut dp = vec![T::max_ident(); v.len()];",
      "    for vi in v {",
      "        let i = dp.lower_bound(|j| vi <= j);",
      "        dp[i] = vi.clone();",
      "    }",
      "    let i = dp.lower_bound(|j| j >= &T::max_ident());",
      "    (i, dp)",
      "}",
      "/// 加減算",
      "pub trait AddSubIdent {",
      "    fn add_sub_ident() -> Self;",
      "}",
      "/// 乗除算",
      "pub trait MulDivIdent {",
      "    fn mul_div_ident() -> Self;",
      "}",
      "/// GCD",
      "pub trait GCDIdent {",
      "    fn gcd_ident() -> Self;",
      "}",
      "/// LCM",
      "pub trait LCMIdent {",
      "    fn lcm_ident() -> Self;",
      "}",
      "/// Max",
      "pub trait MaxIdent {",
      "    fn max_ident() -> Self;",
      "}",
      "/// Min",
      "pub trait MinIdent {",
      "    fn min_ident() -> Self;",
      "}",
      "/// Xor",
      "pub trait XorIdent {",
      "    fn xor_ident() -> Self;",
      "}",
      "/// 変換用",
      "pub struct Num(pub i128);",
      "macro_rules! impl_num_from {",
      "    (\\$ t : ty ) => {",
      "        impl From<Num> for \\$t {",
      "            fn from(t: Num) -> \\$t {",
      "                t.0 as \\$t",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_num_from!(i8);",
      "impl_num_from!(i16);",
      "impl_num_from!(i32);",
      "impl_num_from!(i64);",
      "impl_num_from!(i128);",
      "impl_num_from!(isize);",
      "impl_num_from!(u8);",
      "impl_num_from!(u16);",
      "impl_num_from!(u32);",
      "impl_num_from!(u64);",
      "impl_num_from!(u128);",
      "impl_num_from!(usize);",
      "macro_rules! impl_num_into {",
      "    (\\$ t : ty ) => {",
      "        impl Into<Num> for \\$t {",
      "            fn into(self) -> Num {",
      "                Num(self as i128)",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_num_into!(i8);",
      "impl_num_into!(i16);",
      "impl_num_into!(i32);",
      "impl_num_into!(i64);",
      "impl_num_into!(i128);",
      "impl_num_into!(isize);",
      "impl_num_into!(u8);",
      "impl_num_into!(u16);",
      "impl_num_into!(u32);",
      "impl_num_into!(u64);",
      "impl_num_into!(u128);",
      "impl_num_into!(usize);",
      "impl<T: From<Num>> AddSubIdent for T {",
      "    fn add_sub_ident() -> Self {",
      "        Num(0).into()",
      "    }",
      "}",
      "impl<T: From<Num>> MulDivIdent for T {",
      "    fn mul_div_ident() -> Self {",
      "        Num(1).into()",
      "    }",
      "}",
      "impl<T: From<Num>> GCDIdent for T {",
      "    fn gcd_ident() -> Self {",
      "        Num(0).into()",
      "    }",
      "}",
      "impl<T: From<Num>> LCMIdent for T {",
      "    fn lcm_ident() -> Self {",
      "        Num(1).into()",
      "    }",
      "}",
      "macro_rules! impl_min {",
      "    (\\$ t : ident ) => {",
      "        impl MinIdent for \\$t {",
      "            fn min_ident() -> Self {",
      "                std::\\$t::MIN",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_min!(i8);",
      "impl_min!(i16);",
      "impl_min!(i32);",
      "impl_min!(i64);",
      "impl_min!(i128);",
      "impl_min!(isize);",
      "impl_min!(u8);",
      "impl_min!(u16);",
      "impl_min!(u32);",
      "impl_min!(u64);",
      "impl_min!(u128);",
      "impl_min!(usize);",
      "macro_rules! impl_max {",
      "    (\\$ t : ident ) => {",
      "        impl MaxIdent for \\$t {",
      "            fn max_ident() -> Self {",
      "                std::\\$t::MAX",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_max!(i8);",
      "impl_max!(i16);",
      "impl_max!(i32);",
      "impl_max!(i64);",
      "impl_max!(i128);",
      "impl_max!(isize);",
      "impl_max!(u8);",
      "impl_max!(u16);",
      "impl_max!(u32);",
      "impl_max!(u64);",
      "impl_max!(u128);",
      "impl_max!(usize);",
      "impl<T: From<Num>> XorIdent for T {",
      "    fn xor_ident() -> Self {",
      "        Num(0).into()",
      "    }",
      "}"
    ]
  },
  "math_util": {
    "prefix": "math_util",
    "body": [
      "/// 加減算",
      "pub trait AddSubIdent {",
      "    fn add_sub_ident() -> Self;",
      "}",
      "/// 乗除算",
      "pub trait MulDivIdent {",
      "    fn mul_div_ident() -> Self;",
      "}",
      "/// GCD",
      "pub trait GCDIdent {",
      "    fn gcd_ident() -> Self;",
      "}",
      "/// LCM",
      "pub trait LCMIdent {",
      "    fn lcm_ident() -> Self;",
      "}",
      "/// Max",
      "pub trait MaxIdent {",
      "    fn max_ident() -> Self;",
      "}",
      "/// Min",
      "pub trait MinIdent {",
      "    fn min_ident() -> Self;",
      "}",
      "/// Xor",
      "pub trait XorIdent {",
      "    fn xor_ident() -> Self;",
      "}",
      "/// 変換用",
      "pub struct Num(pub i128);",
      "macro_rules! impl_num_from {",
      "    (\\$ t : ty ) => {",
      "        impl From<Num> for \\$t {",
      "            fn from(t: Num) -> \\$t {",
      "                t.0 as \\$t",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_num_from!(i8);",
      "impl_num_from!(i16);",
      "impl_num_from!(i32);",
      "impl_num_from!(i64);",
      "impl_num_from!(i128);",
      "impl_num_from!(isize);",
      "impl_num_from!(u8);",
      "impl_num_from!(u16);",
      "impl_num_from!(u32);",
      "impl_num_from!(u64);",
      "impl_num_from!(u128);",
      "impl_num_from!(usize);",
      "macro_rules! impl_num_into {",
      "    (\\$ t : ty ) => {",
      "        impl Into<Num> for \\$t {",
      "            fn into(self) -> Num {",
      "                Num(self as i128)",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_num_into!(i8);",
      "impl_num_into!(i16);",
      "impl_num_into!(i32);",
      "impl_num_into!(i64);",
      "impl_num_into!(i128);",
      "impl_num_into!(isize);",
      "impl_num_into!(u8);",
      "impl_num_into!(u16);",
      "impl_num_into!(u32);",
      "impl_num_into!(u64);",
      "impl_num_into!(u128);",
      "impl_num_into!(usize);",
      "impl<T: From<Num>> AddSubIdent for T {",
      "    fn add_sub_ident() -> Self {",
      "        Num(0).into()",
      "    }",
      "}",
      "impl<T: From<Num>> MulDivIdent for T {",
      "    fn mul_div_ident() -> Self {",
      "        Num(1).into()",
      "    }",
      "}",
      "impl<T: From<Num>> GCDIdent for T {",
      "    fn gcd_ident() -> Self {",
      "        Num(0).into()",
      "    }",
      "}",
      "impl<T: From<Num>> LCMIdent for T {",
      "    fn lcm_ident() -> Self {",
      "        Num(1).into()",
      "    }",
      "}",
      "macro_rules! impl_min {",
      "    (\\$ t : ident ) => {",
      "        impl MinIdent for \\$t {",
      "            fn min_ident() -> Self {",
      "                std::\\$t::MIN",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_min!(i8);",
      "impl_min!(i16);",
      "impl_min!(i32);",
      "impl_min!(i64);",
      "impl_min!(i128);",
      "impl_min!(isize);",
      "impl_min!(u8);",
      "impl_min!(u16);",
      "impl_min!(u32);",
      "impl_min!(u64);",
      "impl_min!(u128);",
      "impl_min!(usize);",
      "macro_rules! impl_max {",
      "    (\\$ t : ident ) => {",
      "        impl MaxIdent for \\$t {",
      "            fn max_ident() -> Self {",
      "                std::\\$t::MAX",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_max!(i8);",
      "impl_max!(i16);",
      "impl_max!(i32);",
      "impl_max!(i64);",
      "impl_max!(i128);",
      "impl_max!(isize);",
      "impl_max!(u8);",
      "impl_max!(u16);",
      "impl_max!(u32);",
      "impl_max!(u64);",
      "impl_max!(u128);",
      "impl_max!(usize);",
      "impl<T: From<Num>> XorIdent for T {",
      "    fn xor_ident() -> Self {",
      "        Num(0).into()",
      "    }",
      "}",
      "pub fn pow<T: std::ops::Mul<Output = T> + MulDivIdent + Copy>(x: T, n: u128) -> T {",
      "    if n == 0 {",
      "        T::mul_div_ident()",
      "    } else if n == 1 {",
      "        x",
      "    } else if n % 2 == 1 {",
      "        x * pow(x, n - 1)",
      "    } else {",
      "        pow(x * x, n / 2)",
      "    }",
      "}",
      "pub fn mod_pow<T: std::ops::Mul<Output = T> + std::ops::Rem<Output = T> + MulDivIdent + Copy>(",
      "    x: T,",
      "    n: u128,",
      "    m: T,",
      ") -> T {",
      "    if n == 0 {",
      "        T::mul_div_ident() % m",
      "    } else if n == 1 {",
      "        x % m",
      "    } else if n % 2 == 1 {",
      "        x * mod_pow(x, n - 1, m) % m",
      "    } else {",
      "        mod_pow(x * x % m, n / 2, m)",
      "    }",
      "}",
      "pub fn gcd<T: GCDIdent + std::ops::Rem<Output = T> + Copy + std::cmp::Ord>(a: T, b: T) -> T {",
      "    if b == T::gcd_ident() {",
      "        a",
      "    } else {",
      "        gcd(b, a % b)",
      "    }",
      "}",
      "pub fn ext_gcd(a: i128, b: i128) -> (i128, i128, i128) {",
      "    if a < b {",
      "        let (g, y, x) = ext_gcd(b, a);",
      "        return (g, x, y);",
      "    }",
      "    if b == 0 {",
      "        return (a, 1, 0);",
      "    }",
      "    let (g, x, y) = ext_gcd(b, a % b);",
      "    (g, y, x - a / b * y)",
      "}",
      "pub fn lcm<",
      "    T: GCDIdent",
      "        + std::ops::Mul<Output = T>",
      "        + std::ops::Div<Output = T>",
      "        + std::ops::Rem<Output = T>",
      "        + Copy",
      "        + std::cmp::Ord,",
      ">(",
      "    a: T,",
      "    b: T,",
      ") -> T {",
      "    let g = gcd(a, b);",
      "    a * b / g",
      "}",
      "/// O(√N)",
      "pub fn divisors(n: u128) -> Vec<u128> {",
      "    let mut res = Vec::new();",
      "    for i in 1.. {",
      "        if i * i > n {",
      "            break;",
      "        }",
      "        if n % i == 0 {",
      "            res.push(i);",
      "            if n / i != i {",
      "                res.push(n / i);",
      "            }",
      "        }",
      "    }",
      "    res",
      "}",
      "/// O(√N)",
      "pub fn is_prime(n: u128) -> bool {",
      "    for i in 2.. {",
      "        if i * i > n {",
      "            break;",
      "        }",
      "        if n % i == 0 {",
      "            return false;",
      "        }",
      "    }",
      "    true",
      "}",
      "/// O(√N)",
      "pub fn primes(mut n: u128) -> std::collections::HashMap<u128, u128> {",
      "    let mut res = std::collections::HashMap::new();",
      "    for i in 2.. {",
      "        if i * i > n {",
      "            break;",
      "        }",
      "        let mut ex = 0;",
      "        while n % i == 0 {",
      "            ex += 1;",
      "            n /= i;",
      "        }",
      "        if ex != 0 {",
      "            res.insert(i, ex);",
      "        }",
      "    }",
      "    if n != 0 {",
      "        *res.entry(n).or_insert(0) += 1;",
      "    }",
      "    res",
      "}"
    ]
  },
  "mod_int": {
    "prefix": "mod_int",
    "body": [
      "pub const MOD: i32 = MOD1000000007;",
      "pub const MOD1000000007: i32 = 1000000007;",
      "pub const MOD998244353: i32 = 998244353;",
      "/// 常に設定したModを取り続ける正整数型",
      "#[derive(Debug, Copy, Clone, Ord, PartialOrd, Eq, PartialEq)]",
      "pub struct ModInt {",
      "    /// 保持する値",
      "    value: i32,",
      "}",
      "impl ModInt {",
      "    /// isizeを受け取り、ModIntに変換する",
      "    pub fn new(n: i32) -> Self {",
      "        let mut value = n % MOD;",
      "        if value < 0 {",
      "            value += MOD;",
      "        }",
      "        Self { value }",
      "    }",
      "    /// べき乗計算関数",
      "    /// 二分累乗法を用いるため、計算量はO(log n)",
      "    pub fn pow(self, n: u128) -> Self {",
      "        match n {",
      "            0 => ModInt::new(1),",
      "            1 => self,",
      "            n if n % 2 == 0 => (self * self).pow(n / 2),",
      "            _ => self * self.pow(n - 1),",
      "        }",
      "    }",
      "    /// 逆元を返す",
      "    /// フェルマーの小定理より、べき乗を用いて計算するため、計算量はO(log MOD)",
      "    pub fn inv(self) -> Self {",
      "        self.pow((MOD - 2) as u128)",
      "    }",
      "}",
      "impl std::fmt::Display for ModInt {",
      "    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {",
      "        write!(f, \"{}\", self.value)",
      "    }",
      "}",
      "impl<T: Into<Num>> From<T> for ModInt {",
      "    fn from(t: T) -> Self {",
      "        let n: Num = t.into();",
      "        Self::new((n.0 % MOD as i128) as i32)",
      "    }",
      "}",
      "impl<T: Into<ModInt>> std::ops::Add<T> for ModInt {",
      "    type Output = ModInt;",
      "    fn add(self, rhs: T) -> Self::Output {",
      "        let mut tmp = self.value;",
      "        let t: ModInt = rhs.into();",
      "        tmp += t.value;",
      "        if tmp >= MOD {",
      "            tmp -= MOD;",
      "        }",
      "        Self { value: tmp }",
      "    }",
      "}",
      "impl<T: Into<ModInt>> std::ops::AddAssign<T> for ModInt {",
      "    fn add_assign(&mut self, rhs: T) {",
      "        *self = *self + rhs.into()",
      "    }",
      "}",
      "impl<T: Into<ModInt>> std::ops::Sub<T> for ModInt {",
      "    type Output = ModInt;",
      "    fn sub(self, rhs: T) -> Self::Output {",
      "        let mut tmp = self.value;",
      "        let rhs: ModInt = rhs.into();",
      "        if tmp < rhs.value {",
      "            tmp += MOD;",
      "        }",
      "        tmp -= rhs.value;",
      "        if tmp >= MOD {",
      "            tmp %= MOD;",
      "        }",
      "        Self { value: tmp }",
      "    }",
      "}",
      "impl<T: Into<ModInt>> std::ops::SubAssign<T> for ModInt {",
      "    fn sub_assign(&mut self, rhs: T) {",
      "        *self = *self - rhs.into();",
      "    }",
      "}",
      "impl<T: Into<ModInt>> std::ops::Mul<T> for ModInt {",
      "    type Output = ModInt;",
      "    fn mul(self, rhs: T) -> Self::Output {",
      "        let rhs: ModInt = rhs.into();",
      "        let mut tmp = self.value as i128 * rhs.value as i128;",
      "        if tmp >= MOD as i128 {",
      "            tmp %= MOD as i128;",
      "        }",
      "        Self { value: tmp as i32 }",
      "    }",
      "}",
      "impl<T: Into<ModInt>> std::ops::MulAssign<T> for ModInt {",
      "    fn mul_assign(&mut self, rhs: T) {",
      "        *self = *self * rhs.into();",
      "    }",
      "}",
      "impl<T: Into<ModInt>> std::ops::Div<T> for ModInt {",
      "    type Output = ModInt;",
      "    fn div(self, rhs: T) -> Self::Output {",
      "        let rhs: ModInt = rhs.into();",
      "        self * rhs.inv()",
      "    }",
      "}",
      "impl<T: Into<ModInt>> std::ops::DivAssign<T> for ModInt {",
      "    fn div_assign(&mut self, rhs: T) {",
      "        let rhs = rhs.into();",
      "        *self = *self / rhs;",
      "    }",
      "}",
      "/// 二項係数を高速に計算するテーブルを作成する",
      "/// 構築 O(N)",
      "/// クエリ O(1)",
      "/// メモリ O(N)",
      "pub struct CombTable {",
      "    fac: Vec<ModInt>,",
      "    f_inv: Vec<ModInt>,",
      "}",
      "impl CombTable {",
      "    /// O(N)で構築",
      "    pub fn new(n: usize) -> Self {",
      "        let mut fac = vec![ModInt::new(1); n + 1];",
      "        let mut f_inv = vec![ModInt::new(1); n + 1];",
      "        let mut inv = vec![ModInt::new(1); n + 1];",
      "        inv[0] = ModInt::new(0);",
      "        for i in 2..=n {",
      "            fac[i] = fac[i - 1] * i;",
      "            inv[i] =",
      "                ModInt::new(MOD) - inv[(MOD % i as i32) as usize] * ModInt::new(MOD / i as i32);",
      "            f_inv[i] = f_inv[i - 1] * inv[i];",
      "        }",
      "        Self { fac, f_inv }",
      "    }",
      "    /// nCkをO(1)で計算",
      "    pub fn comb(&self, n: usize, k: usize) -> ModInt {",
      "        if n < k {",
      "            return ModInt::new(0);",
      "        }",
      "        self.fac[n] * (self.f_inv[k] * self.f_inv[n - k])",
      "    }",
      "}",
      "/// 加減算",
      "pub trait AddSubIdent {",
      "    fn add_sub_ident() -> Self;",
      "}",
      "/// 乗除算",
      "pub trait MulDivIdent {",
      "    fn mul_div_ident() -> Self;",
      "}",
      "/// GCD",
      "pub trait GCDIdent {",
      "    fn gcd_ident() -> Self;",
      "}",
      "/// LCM",
      "pub trait LCMIdent {",
      "    fn lcm_ident() -> Self;",
      "}",
      "/// Max",
      "pub trait MaxIdent {",
      "    fn max_ident() -> Self;",
      "}",
      "/// Min",
      "pub trait MinIdent {",
      "    fn min_ident() -> Self;",
      "}",
      "/// Xor",
      "pub trait XorIdent {",
      "    fn xor_ident() -> Self;",
      "}",
      "/// 変換用",
      "pub struct Num(pub i128);",
      "macro_rules! impl_num_from {",
      "    (\\$ t : ty ) => {",
      "        impl From<Num> for \\$t {",
      "            fn from(t: Num) -> \\$t {",
      "                t.0 as \\$t",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_num_from!(i8);",
      "impl_num_from!(i16);",
      "impl_num_from!(i32);",
      "impl_num_from!(i64);",
      "impl_num_from!(i128);",
      "impl_num_from!(isize);",
      "impl_num_from!(u8);",
      "impl_num_from!(u16);",
      "impl_num_from!(u32);",
      "impl_num_from!(u64);",
      "impl_num_from!(u128);",
      "impl_num_from!(usize);",
      "macro_rules! impl_num_into {",
      "    (\\$ t : ty ) => {",
      "        impl Into<Num> for \\$t {",
      "            fn into(self) -> Num {",
      "                Num(self as i128)",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_num_into!(i8);",
      "impl_num_into!(i16);",
      "impl_num_into!(i32);",
      "impl_num_into!(i64);",
      "impl_num_into!(i128);",
      "impl_num_into!(isize);",
      "impl_num_into!(u8);",
      "impl_num_into!(u16);",
      "impl_num_into!(u32);",
      "impl_num_into!(u64);",
      "impl_num_into!(u128);",
      "impl_num_into!(usize);",
      "impl<T: From<Num>> AddSubIdent for T {",
      "    fn add_sub_ident() -> Self {",
      "        Num(0).into()",
      "    }",
      "}",
      "impl<T: From<Num>> MulDivIdent for T {",
      "    fn mul_div_ident() -> Self {",
      "        Num(1).into()",
      "    }",
      "}",
      "impl<T: From<Num>> GCDIdent for T {",
      "    fn gcd_ident() -> Self {",
      "        Num(0).into()",
      "    }",
      "}",
      "impl<T: From<Num>> LCMIdent for T {",
      "    fn lcm_ident() -> Self {",
      "        Num(1).into()",
      "    }",
      "}",
      "macro_rules! impl_min {",
      "    (\\$ t : ident ) => {",
      "        impl MinIdent for \\$t {",
      "            fn min_ident() -> Self {",
      "                std::\\$t::MIN",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_min!(i8);",
      "impl_min!(i16);",
      "impl_min!(i32);",
      "impl_min!(i64);",
      "impl_min!(i128);",
      "impl_min!(isize);",
      "impl_min!(u8);",
      "impl_min!(u16);",
      "impl_min!(u32);",
      "impl_min!(u64);",
      "impl_min!(u128);",
      "impl_min!(usize);",
      "macro_rules! impl_max {",
      "    (\\$ t : ident ) => {",
      "        impl MaxIdent for \\$t {",
      "            fn max_ident() -> Self {",
      "                std::\\$t::MAX",
      "            }",
      "        }",
      "    };",
      "}",
      "impl_max!(i8);",
      "impl_max!(i16);",
      "impl_max!(i32);",
      "impl_max!(i64);",
      "impl_max!(i128);",
      "impl_max!(isize);",
      "impl_max!(u8);",
      "impl_max!(u16);",
      "impl_max!(u32);",
      "impl_max!(u64);",
      "impl_max!(u128);",
      "impl_max!(usize);",
      "impl<T: From<Num>> XorIdent for T {",
      "    fn xor_ident() -> Self {",
      "        Num(0).into()",
      "    }",
      "}"
    ]
  },
  "multi_set": {
    "prefix": "multi_set",
    "body": [
      "pub struct MultiSet<K: Ord + Clone> {",
      "    map: std::collections::BTreeMap<K, usize>,",
      "    counter: usize,",
      "}",
      "impl<K: Ord + Clone> MultiSet<K> {",
      "    pub fn new() -> Self {",
      "        Self {",
      "            map: std::collections::BTreeMap::new(),",
      "            counter: 0,",
      "        }",
      "    }",
      "    pub fn insert(&mut self, k: K) {",
      "        *self.map.entry(k).or_insert(0) += 1;",
      "        self.counter += 1;",
      "    }",
      "    pub fn remove_one(&mut self, k: &K) -> bool {",
      "        if !self.contains(k) {",
      "            false",
      "        } else {",
      "            self.counter -= 1;",
      "            if self.map[k] == 1 {",
      "                self.map.remove(k);",
      "            } else {",
      "                let v = self.map[k];",
      "                self.map.insert(k.clone(), v - 1);",
      "            }",
      "            true",
      "        }",
      "    }",
      "    pub fn remove_all(&mut self, k: &K) -> bool {",
      "        if !self.contains(k) {",
      "            false",
      "        } else {",
      "            let v = self.map[k];",
      "            self.counter -= v;",
      "            self.map.remove(k);",
      "            true",
      "        }",
      "    }",
      "    pub fn clear(&mut self) {",
      "        self.map.clear();",
      "        self.counter = 0;",
      "    }",
      "    pub fn contains(&self, k: &K) -> bool {",
      "        self.map.contains_key(k)",
      "    }",
      "    pub fn len(&self) -> usize {",
      "        self.counter",
      "    }",
      "    pub fn is_empty(&self) -> bool {",
      "        self.map.is_empty()",
      "    }",
      "    pub fn first(&self) -> Option<&K> {",
      "        self.map.iter().next().map(|o| o.0)",
      "    }",
      "    pub fn last(&self) -> Option<&K> {",
      "        self.map.iter().next_back().map(|o| o.0)",
      "    }",
      "    pub fn pop_first(&mut self) -> Option<K> {",
      "        if let Some(k) = self.first().map(|o| o.clone()) {",
      "            self.remove_one(&k);",
      "            Some(k)",
      "        } else {",
      "            None",
      "        }",
      "    }",
      "    pub fn pop_last(&mut self) -> Option<K> {",
      "        if let Some(k) = self.last().map(|o| o.clone()) {",
      "            self.remove_one(&k);",
      "            Some(k)",
      "        } else {",
      "            None",
      "        }",
      "    }",
      "}",
      "impl<K: Ord + Clone> IntoIterator for MultiSet<K> {",
      "    type Item = K;",
      "    type IntoIter = std::vec::IntoIter<Self::Item>;",
      "    fn into_iter(self) -> Self::IntoIter {",
      "        let mut vec = Vec::new();",
      "        self.map.into_iter().for_each(|(k, v)| {",
      "            for _ in 0..v {",
      "                vec.push(k.clone());",
      "            }",
      "        });",
      "        vec.into_iter()",
      "    }",
      "}"
    ]
  },
  "rle": {
    "prefix": "rle",
    "body": [
      "pub fn rle<T: Eq + Clone>(s: &[T]) -> Vec<(T, usize)> {",
      "    let mut res: Vec<(T, usize)> = vec![];",
      "    for si in s {",
      "        if res.is_empty() || &(res[res.len() - 1].0) != si {",
      "            res.push((si.clone(), 1));",
      "        } else {",
      "            let l = res.len();",
      "            let (_, k) = &mut res[l - 1];",
      "            *k += 1;",
      "        }",
      "    }",
      "    res",
      "}"
    ]
  },
  "search_util": {
    "prefix": "search_util",
    "body": [
      "pub fn around((i, j): (usize, usize), h: usize, w: usize) -> Vec<(usize, usize)> {",
      "    let (i, j) = (i as isize, j as isize);",
      "    vec![",
      "        (i - 1, j - 1),",
      "        (i - 1, j),",
      "        (i - 1, j + 1),",
      "        (i, j - 1),",
      "        (i, j + 1),",
      "        (i + 1, j - 1),",
      "        (i + 1, j),",
      "        (i + 1, j + 1),",
      "    ]",
      "    .into_iter()",
      "    .filter(|(ii, jj)| (0..h as isize).contains(ii) && (0..w as isize).contains(jj))",
      "    .map(|(ii, jj)| (ii as usize, jj as usize))",
      "    .collect::<Vec<_>>()",
      "}",
      "pub fn next((i, j): (usize, usize), h: usize, w: usize) -> Vec<(usize, usize)> {",
      "    let (i, j) = (i as isize, j as isize);",
      "    vec![(i - 1, j), (i, j - 1), (i, j + 1), (i + 1, j)]",
      "        .into_iter()",
      "        .filter(|(ii, jj)| (0..h as isize).contains(ii) && (0..w as isize).contains(jj))",
      "        .map(|(ii, jj)| (ii as usize, jj as usize))",
      "        .collect::<Vec<_>>()",
      "}"
    ]
  },
  "seg_tree": {
    "prefix": "seg_tree",
    "body": [
      "/// セグ木にのせるMonoid",
      "pub trait Monoid {",
      "    type Item: std::fmt::Debug + Clone;",
      "    /// 単位元",
      "    fn id() -> Self::Item;",
      "    /// 二項演算",
      "    fn op(a: &Self::Item, b: &Self::Item) -> Self::Item;",
      "}",
      "pub struct SegTree<M: Monoid> {",
      "    data: Vec<M::Item>,",
      "    n: usize,",
      "}",
      "impl<M: Monoid> SegTree<M> {",
      "    /// すべて単位元で埋めた長さnのセグ木の生成",
      "    pub fn new(n: usize) -> Self {",
      "        let mut i = 1;",
      "        while i < n {",
      "            i *= 2;",
      "        }",
      "        let data = (0..2 * i - 1).map(|_| M::id()).collect::<Vec<_>>();",
      "        Self { data, n: i }",
      "    }",
      "    /// O(n)でスライスからセグ木を生成",
      "    pub fn from_slice(slice: &[M::Item]) -> Self {",
      "        let mut i = 1;",
      "        while i < slice.len() {",
      "            i *= 2;",
      "        }",
      "        let mut data = vec![M::id(); 2 * i - 1];",
      "        for j in 0..slice.len() {",
      "            data[j + i - 1] = slice[j].clone();",
      "        }",
      "        if slice.len() != 1 {",
      "            for j in (0..=(i - 2)).rev() {",
      "                data[j] = M::op(&data[j * 2 + 1], &data[j * 2 + 2]);",
      "            }",
      "        }",
      "        Self { data, n: i }",
      "    }",
      "    /// 一点更新",
      "    pub fn set(&mut self, mut i: usize, x: M::Item) {",
      "        i += self.n - 1;",
      "        self.data[i] = x.clone();",
      "        while i > 0 {",
      "            i = (i - 1) / 2;",
      "            self.data[i] = M::op(&self.data[i * 2 + 1], &self.data[i * 2 + 2]);",
      "        }",
      "    }",
      "    /// 一点取得",
      "    pub fn get(&self, mut i: usize) -> &M::Item {",
      "        i += self.n - 1;",
      "        &self.data[i]",
      "    }",
      "    /// 区間クエリ",
      "    /// [l,r)の演算結果を求める",
      "    pub fn fold(&self, mut l: usize, mut r: usize) -> M::Item {",
      "        let mut l_ans = M::id();",
      "        let mut r_ans = M::id();",
      "        l += self.n - 1;",
      "        r += self.n - 1;",
      "        while l < r {",
      "            if l & 1 == 0 {",
      "                l_ans = M::op(&l_ans, &self.data[l]);",
      "            }",
      "            if r & 1 == 0 {",
      "                r_ans = M::op(&self.data[r - 1], &r_ans);",
      "                r -= 2;",
      "            }",
      "            l >>= 1;",
      "            r >>= 1;",
      "        }",
      "        M::op(&l_ans, &r_ans)",
      "    }",
      "}",
      "pub struct Max;",
      "pub struct Min;",
      "pub struct Sum;",
      "pub struct Mul;",
      "pub struct Xor;",
      "impl Monoid for Max {",
      "    type Item = i128;",
      "    fn id() -> Self::Item {",
      "        std::i128::MIN",
      "    }",
      "    fn op(a: &Self::Item, b: &Self::Item) -> Self::Item {",
      "        *a.min(b)",
      "    }",
      "}",
      "impl Monoid for Min {",
      "    type Item = i128;",
      "    fn id() -> Self::Item {",
      "        std::i128::MAX",
      "    }",
      "    fn op(a: &Self::Item, b: &Self::Item) -> Self::Item {",
      "        *a.max(b)",
      "    }",
      "}",
      "impl Monoid for Sum {",
      "    type Item = i128;",
      "    fn id() -> Self::Item {",
      "        0",
      "    }",
      "    fn op(a: &Self::Item, b: &Self::Item) -> Self::Item {",
      "        a + b",
      "    }",
      "}",
      "impl Monoid for Mul {",
      "    type Item = i128;",
      "    fn id() -> Self::Item {",
      "        1",
      "    }",
      "    fn op(a: &Self::Item, b: &Self::Item) -> Self::Item {",
      "        a * b",
      "    }",
      "}",
      "impl Monoid for Xor {",
      "    type Item = i128;",
      "    fn id() -> Self::Item {",
      "        0",
      "    }",
      "    fn op(a: &Self::Item, b: &Self::Item) -> Self::Item {",
      "        a ^ b",
      "    }",
      "}",
      "pub type MaxSegTree = SegTree<Max>;",
      "pub type MinSegTree = SegTree<Min>;",
      "pub type SumSegTree = SegTree<Sum>;",
      "pub type MulSegTree = SegTree<Mul>;",
      "pub type XorSegTree = SegTree<Xor>;"
    ]
  },
  "union_find": {
    "prefix": "union_find",
    "body": [
      "/// UnionFind構造体",
      "pub struct UnionFindTree {",
      "    /// 頂点`i`の親を格納する配列",
      "    parents: Vec<usize>,",
      "    /// 頂点`i`が親であるときのその木の頂点数",
      "    sizes: Vec<usize>,",
      "    /// 重み付きUnionFindを使う際の重みの格納配列",
      "    weights: Vec<isize>,",
      "    /// 頂点`i`が属する木がループを持っているかどうか",
      "    has_loops: Vec<bool>,",
      "}",
      "impl UnionFindTree {",
      "    /// UnionFind初期化",
      "    /// 計算量はO(n)",
      "    pub fn new(n: usize) -> Self {",
      "        let parents = (0..n).collect();",
      "        let sizes = vec![1; n];",
      "        let weights = vec![0; n];",
      "        let has_loops = vec![false; n];",
      "        UnionFindTree {",
      "            parents,",
      "            sizes,",
      "            weights,",
      "            has_loops,",
      "        }",
      "    }",
      "    /// 親を再帰的に求め、途中の計算結果をもとに親の書き換えを行う関数",
      "    /// 計算量はO(a(n)))",
      "    pub fn root(&mut self, x: usize) -> usize {",
      "        if self.parents[x] == x {",
      "            x",
      "        } else {",
      "            let tmp = self.root(self.parents[x]);",
      "            self.weights[x] += self.weights[self.parents[x]];",
      "            self.parents[x] = tmp;",
      "            tmp",
      "        }",
      "    }",
      "    pub fn size(&mut self, x: usize) -> usize {",
      "        let y = self.root(x);",
      "        self.sizes[y]",
      "    }",
      "    pub fn has_loop(&mut self, x: usize) -> bool {",
      "        let y = self.root(x);",
      "        self.has_loops[y]",
      "    }",
      "    /// 2つの頂点が同じ木に属しているかの判定",
      "    /// `self.root()`を呼び出すため、`&mut self`を引数に取る。そのため、命名に`is_`を使っていない",
      "    /// 計算量はO(a(n))",
      "    pub fn same(&mut self, x: usize, y: usize) -> bool {",
      "        self.root(x) == self.root(y)",
      "    }",
      "    /// 重み付きUnionFindを考える際のUnite関数",
      "    /// 計算量はO(a(n))",
      "    pub fn unite_with_weight(&mut self, x: usize, y: usize, w: isize) {",
      "        let root_x = self.root(x);",
      "        let root_y = self.root(y);",
      "        if self.same(x, y) {",
      "            self.has_loops[root_x] = true;",
      "            self.has_loops[root_y] = true;",
      "        } else if self.sizes[root_x] >= self.sizes[root_y] {",
      "            self.parents[root_y] = root_x;",
      "            self.sizes[root_x] += self.sizes[root_y];",
      "            self.weights[root_y] = -w - self.weights[y] + self.weights[x];",
      "        } else {",
      "            self.parents[root_x] = root_y;",
      "            self.sizes[root_y] += self.sizes[root_x];",
      "            self.weights[root_x] = w + self.weights[y] - self.weights[x];",
      "        }",
      "    }",
      "    /// 重みを考慮しない際のUnite関数",
      "    /// 重みとして0を与えているだけであり、計算量は同じくO(a(n))",
      "    pub fn unite(&mut self, x: usize, y: usize) {",
      "        self.unite_with_weight(x, y, 0);",
      "    }",
      "    /// 重み付きUnionFindにおいて、2つの頂点の距離を返す関数",
      "    /// 2つの頂点が同じ木に属していない場合は`None`を返す",
      "    pub fn diff(&mut self, x: usize, y: usize) -> Option<isize> {",
      "        if self.same(x, y) {",
      "            Some(self.weights[x] - self.weights[y])",
      "        } else {",
      "            None",
      "        }",
      "    }",
      "    pub fn is_parent(&self, x: usize) -> bool {",
      "        self.parents[x] == x",
      "    }",
      "}"
    ]
  }
}
